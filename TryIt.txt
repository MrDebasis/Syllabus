@AuraEnabled
public static void saveRecords(List<Map<String, Object>> payloadList) {
    Map<String, List<SObject>> recordsToUpdateByObject = new Map<String, List<SObject>>();

    try {
        for (Map<String, Object> payload : payloadList) {
            String objectApiName = (String) payload.get('objectApiName');
            String recordId = (String) payload.get('Id'); // Id field

            // Get SObjectType
            SObjectType sObjectType = Schema.getGlobalDescribe().get(objectApiName);
            if (sObjectType == null) {
                throw new AuraHandledException('Invalid objectApiName: ' + objectApiName);
            }

            // Get Field Describe Info
            Map<String, Schema.SObjectField> fieldMap = sObjectType.getDescribe().fields.getMap();
            SObject sObj = sObjectType.newSObject(recordId);

            for (String fieldName : payload.keySet()) {
                if (fieldName == 'Id' || fieldName == 'objectApiName') continue;

                if (!fieldMap.containsKey(fieldName)) {
                    throw new AuraHandledException('Field does not exist on ' + objectApiName + ': ' + fieldName);
                }

                Schema.DisplayType fieldType = fieldMap.get(fieldName).getDescribe().getType();
                Object updatedValue = payload.get(fieldName);

                // Handle null values
                if (updatedValue == null) {
                    sObj.put(fieldName, null);
                    continue;
                }

                // Convert based on data type
                switch on fieldType {
                    when DATE {
                        sObj.put(fieldName, Date.valueOf((String) updatedValue));
                    }
                    when DATETIME {
                        sObj.put(fieldName, DateTime.valueOf((String) updatedValue));
                    }
                    when BOOLEAN {
                        sObj.put(fieldName, Boolean.valueOf((String) updatedValue));
                    }
                    when INTEGER {
                        sObj.put(fieldName, Integer.valueOf((String) updatedValue));
                    }
                    when DOUBLE {
                        sObj.put(fieldName, Double.valueOf((String) updatedValue));
                    }
                    when CURRENCY {
                        sObj.put(fieldName, Decimal.valueOf((String) updatedValue));
                    }
                    when PERCENT {
                        sObj.put(fieldName, Decimal.valueOf((String) updatedValue));
                    }
                    when else {
                        sObj.put(fieldName, updatedValue);
                    }
                }
            }

            // Collect for DML
            if (!recordsToUpdateByObject.containsKey(objectApiName)) {
                recordsToUpdateByObject.put(objectApiName, new List<SObject>());
            }
            recordsToUpdateByObject.get(objectApiName).add(sObj);
        }

        // Perform DML
        for (String objName : recordsToUpdateByObject.keySet()) {
            update recordsToUpdateByObject.get(objName);
        }

    } catch (Exception ex) {
        System.debug('Error: ' + ex.getMessage());
        throw new AuraHandledException('Save failed: ' + ex.getMessage());
    }
}


import saveRecords from '@salesforce/apex/YourApexClass.saveRecords';

async handleSave(event) {
    const objectName = event.target.dataset.obj;
    const draftValues = event.detail.draftValues;

    // Add objectApiName to each record
    const payloadList = draftValues.map(d => ({
        ...d,
        objectApiName: objectName
    }));

    try {
        await saveRecords({ payloadList });
        this.tables[objectName].draftValues = [];

        // Optionally refresh table data
        this.loadTables();
    } catch (error) {
        console.error('Error saving records:', error);
    }
}
