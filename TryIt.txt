@AuraEnabled(cacheable=false)
    public static void saveRecord(Map<String, Object> payload) {
        try {
            // Extract recordId, objectApiName, fieldName, and updatedValue from the payload
            String recordId = (String) payload.get('recordId');
            String objectApiName = (String) payload.get('objectApiName');
            String fieldName = (String) payload.get('fieldName');
            Object updatedValue = payload.get('updatedValue');

            System.debug('Received Payload: ' + payload);
            System.debug('RecordId: ' + recordId + ', ObjectApiName: ' + objectApiName + ', FieldName: ' + fieldName + ', UpdatedValue: ' + updatedValue);

            // Get SObject Type dynamically from the objectApiName
            SObjectType sObjectType = Schema.getGlobalDescribe().get(objectApiName);
            if (sObjectType == null) {
                throw new IllegalArgumentException('Invalid objectApiName: ' + objectApiName);
            }

            SObject recordToUpdate = sObjectType.newSObject(recordId);
            Map<String, Schema.SObjectField> fieldMap = sObjectType.getDescribe().fields.getMap();

            // Ensure that the field exists
            if (!fieldMap.containsKey(fieldName)) {
                throw new IllegalArgumentException('Field does not exist: ' + fieldName);
            }

            // Update the field based on its type
            Schema.SObjectField field = fieldMap.get(fieldName);
            Schema.DisplayType fieldType = field.getDescribe().getType();

            if (updatedValue == null) {
                throw new IllegalArgumentException('Updated value cannot be null.');
            }

            switch on fieldType {
                when DATE {
                    recordToUpdate.put(fieldName, Date.valueOf((String) updatedValue));
                }
                when DATETIME {
                    recordToUpdate.put(fieldName, DateTime.valueOf((String) updatedValue));
                }
                when BOOLEAN {
                    recordToUpdate.put(fieldName, Boolean.valueOf((String) updatedValue));
                }
                when INTEGER {
                    recordToUpdate.put(fieldName, Integer.valueOf((String) updatedValue));
                }
                when DOUBLE {
                    recordToUpdate.put(fieldName, Double.valueOf((String) updatedValue));
                }
                when CURRENCY {
                    recordToUpdate.put(fieldName, Decimal.valueOf((String) updatedValue));
                }
                when else {
                    recordToUpdate.put(fieldName, updatedValue);
                }
            }

            // Update the record
            update recordToUpdate;

        } catch (Exception e) {
            System.debug('Error updating record: ' + e.getMessage());
            throw new AuraHandledException('Error updating record: ' + e.getMessage());
        }
    }
import { LightningElement, track,api } from 'lwc';
import getObjectTables from '@salesforce/apex/PSSTrackerCaseController.getTableConfigs';

export default class Psp_PSSTrackerDataTableLWCComp extends LightningElement {
    @track tables = {};
    loading = false;
    error;
    @api caseId ='';
    connectedCallback() {
        this.loadTables();
    }

    async loadTables() {
        this.loading = true;
        this.error = null;

        try {
           // const caseId = '50023000003st7sAAA'; // Replace with dynamic Case Id if needed
            const result = await getObjectTables({ caseId : this.caseId });
            console.log('Apex result:', JSON.stringify(result));
            this.populateTables(result);
        } catch (e) {
            this.error = e.body?.message || e.message;
            console.error('Error loading tables:', e);
        } finally {
            this.loading = false;
        }
    }

    populateTables(result) {
        this.tables = {};
        for (const [objectName, wrapper] of Object.entries(result)) {
            let recordsArray = Object.values(wrapper.data);
            if (objectName == 'HealthCloudGA__ContactContactRelation__c') {
                recordsArray = recordsArray.map(record => ({
                    ...record,
                    accountUrl: record.Account__c
                        ? `/lightning/r/Account/${record.Account__c}/view`
                        : null
                }));
            }

            if (objectName == 'echosign_dev1__SIGN_Agreement__c') {
                recordsArray = recordsArray.map(record => ({
                    ...record,
                    tripUrl: record.Trip__c
                        ? `/lightning/r/Trip__c/${record.Trip__c}/view`
                        : null,
                    agreementUrl: record.Id
                        ? `/lightning/r/echosign_dev1__SIGN_Agreement__c/${record.Id}/view`
                        : null
                }));
            }

            if (objectName == 'echosign_dev1__SIGN_Agreement__c') {
                recordsArray = recordsArray.map(record => ({
                    ...record,
                    tripUrl: record.Trip__c
                        ? `/lightning/r/Trip__c/${record.Trip__c}/view`
                        : null,
                    agreementUrl: record.Id
                        ? `/lightning/r/echosign_dev1__SIGN_Agreement__c/${record.Id}/view`
                        : null
                }));
            }

            
            if (objectName == 'Reimbursement__c') {
                recordsArray = recordsArray.map(record => ({
                    ...record,
                    reimbursementTripUrl: record.CreatedFromTrip__c
                        ? `/lightning/r/Trip__c/${record.CreatedFromTrip__c}/view`
                        : null,
                    reimbursementNameUrl: record.Id
                        ? `/lightning/r/Reimbursement__c/${record.Id}/view`
                        : null
                }));
            }


            this.tables[objectName] = {
                columns: this.buildLightningColumns(wrapper.columns,objectName),
                data: recordsArray,
                draftValues: [],
                sortedBy: '',
                sortedDirection: 'asc' // need to make it dynamic
            };
        }
    }

    
    buildLightningColumns(columns,objectName) {
        return columns
            .filter(col => col.visible)
            .sort((a, b) => {
                if (a.PSSViewColumnOrder__c != null && b.PSSViewColumnOrder__c != null) {
                    return a.PSSViewColumnOrder__c - b.PSSViewColumnOrder__c;
                }
                return a.column_id.localeCompare(b.column_id);
            })
            .map(col => {
                let type = 'text';
                let typeAttributes;

                const dataType = col.data_type?.toLowerCase() || 'string';
                
                
                if (objectName === 'HealthCloudGA__ContactContactRelation__c' && col.column_id === 'ContactName__c') {
                    type = 'url';
                    typeAttributes = {
                        label: { fieldName: 'ContactName__c' },
                        target: '_blank',
                        url: {
                            fieldName:  'accountUrl'
                        }
                    };
                    return {
                        label: col.label,
                        fieldName: 'accountUrl', // mapped field
                        editable: col.editable,
                        sortable: col.isSortingApplied,
                        type,
                        typeAttributes
                    };
                }
                if (objectName == 'echosign_dev1__SIGN_Agreement__c' && col.column_id === 'TripName__c') {
                    type = 'url';
                    typeAttributes = {
                        label: { fieldName: 'TripName__c' },
                        target: '_blank',
                        url: {
                            fieldName:  'tripUrl'
                        }
                    };
                    return {
                        label: col.label,
                        fieldName: 'tripUrl',
                        editable: col.editable,
                        sortable: col.isSortingApplied,
                        type,
                        typeAttributes
                    };
                }
                 if (objectName === 'Reimbursement__c' && col.column_id === 'TripName__c') {
                    type = 'url';
                    typeAttributes = {
                        label: { fieldName: 'TripName__c' },
                        target: '_blank',
                        url: {
                            fieldName:  'reimbursementTripUrl'
                        }
                    };
                    return {
                        label: col.label,
                        fieldName: 'reimbursementTripUrl',
                        editable: col.editable,
                        sortable: col.isSortingApplied,
                        type,
                        typeAttributes
                    };
                }  

                if (objectName === 'Reimbursement__c' && col.column_id === 'Name') {
                    type = 'url';
                    typeAttributes = {
                        label: { fieldName: 'Name' },
                        target: '_blank',
                        url: {
                            fieldName:  'reimbursementNameUrl'
                        }
                    };
                    return {
                        label: col.label,
                        fieldName: 'reimbursementNameUrl',
                        editable: col.editable,
                        sortable: col.isSortingApplied,
                        type,
                        typeAttributes
                    };
                }  

                else {
                    switch (dataType) {
                        case 'number':
                            type = 'number';
                            break;
                        case 'date':
                        case 'datetime':
                            type = 'date';
                                typeAttributes = {
                                    year: 'numeric',
                                    month: '2-digit',
                                    day: '2-digit'
                                };
                            break;
                    case 'currency':
                        type = 'currency';
                        typeAttributes = {
                            currencyCode: 'USD', // or use { fieldName: 'CurrencyIsoCode' } if dynamic
                            minimumFractionDigits: 2
                        };
                        break;
                        case 'picklist':
                            type = 'picklist';
                            if (col.picklistValues) {
                                const options = col.picklistValues.split(';').map(val => ({
                                    label: val.trim(),
                                    value: val.trim()
                                }));
                                typeAttributes = {
                                    options,
                                    placeholder: 'Select',
                                    value: { fieldName: col.column_id },
                                    context: { fieldName: 'Id' }
                                };
                            }
                            break;
                        default:
                            // Detect and handle phone field
                            if (col.column_id.toLowerCase().includes('phone')) {
                                type = 'phone';
                            } else {
                                type = 'text';
                            }
                    }
                }

                return {
                    label: col.label,
                    fieldName: col.column_id,
                    editable: col.editable,
                    sortable: col.isSortingApplied,
                    type,
                    typeAttributes
                };
            });
    }

    get caseTable() {
        return this.tables['Case'];
    }

    get associatedContact() {
        return this.tables['HealthCloudGA__ContactContactRelation__c'];
    }

    get getAgreement() {
        return this.tables['echosign_dev1__SIGN_Agreement__c'];
      }

      get getReimbursemwnt() {
        return this.tables['Reimbursement__c'];
      }

      get getCaseComment() {
        return this.tables['CaseComment'];
      }
  
    get contactTable() {
        return this.tables['Contact'];
    }

    handleSave(event) {
        const objectName = event.target.dataset.obj;
        const draftValues = event.detail.draftValues;
        console.log(`Saving for ${objectName}:`, draftValues);

        this.tables[objectName].data = this.tables[objectName].data.map(row => {
            const draft = draftValues.find(d => d.Id === row.Id);
            return draft ? { ...row, ...draft } : row;
        });

        this.tables[objectName].draftValues = [];
    }

    handleSort(event) {
        const { fieldName, sortDirection } = event.detail;
        const objectName = event.target.dataset.obj;

        let sortedData = [...this.tables[objectName].data];
        sortedData.sort((a, b) => {
            const aVal = a[fieldName] ?? '';
            const bVal = b[fieldName] ?? '';
            return sortDirection === 'asc'
                ? aVal > bVal ? 1 : -1
                : aVal < bVal ? 1 : -1;
        });

        this.tables[objectName].data = sortedData;
        this.tables[objectName].sortedBy = fieldName;
        this.tables[objectName].sortedDirection = sortDirection;
    }
}
