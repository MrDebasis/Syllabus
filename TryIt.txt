import { LightningElement, track } from 'lwc';

export default class CaseFilter extends LightningElement {
    @track cases = []; // full data
    @track casesFiltered = []; // filtered output
    @track filtersLength = 0;

    connectedCallback() {
        this.cases = this.mockCases(); // Load sample data
        this.applyFilters();
    }

    applyFilters() {
        const filters = [
            {
                field: "Trips__r",
                operator: "NestedBetween",
                startField: "InfusionMonitoringArrivalTravelDate__c",
                endField: "InfusionMonitoringReturnTravelDate__c",
                value: ["2025-04-01", "2025-04-30"]
            }
        ];

        this.filtersLength = filters.length;

        this.casesFiltered = this.cases.filter(record => {
            return filters.every(filter => this.evaluateField(record, filter));
        });

        console.log("âœ… Filtered Output:", this.casesFiltered);
    }

    evaluateField(record, filter) {
        const path = filter.field.split('.');
        return this.resolvePath(record, path, filter);
    }

    resolvePath(obj, pathArr, filter) {
        const key = pathArr[0];

        if (Array.isArray(obj)) {
            return obj.some(item => this.resolvePath(item, pathArr, filter));
        }

        if (pathArr.length === 1) {
            const value = obj?.[key];

            if (filter.operator === "NestedBetween") {
                return this.matchNestedBetween(value, filter);
            }

            return this.matchFilter(value, filter);
        }

        const next = obj?.[key];

        if (Array.isArray(next)) {
            return next.some(item => this.resolvePath(item, pathArr.slice(1), filter));
        }

        return this.resolvePath(next, pathArr.slice(1), filter);
    }

    matchFilter(value, filter) {
        switch (filter.operator) {
            case "in":
            case "includes":
                return filter.value.includes(value);

            case "equals":
                return value === filter.value;

            case "Date":
                if (!value) return false;
                return this.stripTime(new Date(value)).getTime() === this.stripTime(new Date(filter.value)).getTime();

            case "Between":
                if (!value) return false;
                const valDate = this.stripTime(new Date(value));
                const [start, end] = filter.value.map(v => this.stripTime(new Date(v)));
                return valDate >= start && valDate <= end;

            default:
                return true;
        }
    }

    matchNestedBetween(value, filter) {
        if (!value || !Array.isArray(value)) return false;

        const [startDate, endDate] = filter.value.map(date => this.stripTime(new Date(date)));
        let isDateCheckedRangeBetween = false;

        for (const item of value) {
            const startFieldValue = item[filter.startField];
            const endFieldValue = item[filter.endField];

            const startDateValue = startFieldValue ? this.stripTime(new Date(startFieldValue)) : null;
            const endDateValue = endFieldValue ? this.stripTime(new Date(endFieldValue)) : null;

            if (startDateValue === null && endDateValue === null) continue;

            const isStartInRange =
                startDateValue &&
                startDateValue >= startDate &&
                startDateValue <= endDate;

            const isEndInRange =
                endDateValue &&
                endDateValue >= startDate &&
                endDateValue <= endDate;

            if (isStartInRange || isEndInRange) {
                isDateCheckedRangeBetween = true;
                break;
            }
        }

        return isDateCheckedRangeBetween;
    }

    stripTime(date) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }

    // Sample Data
    mockCases() {
        return [
            {
                CaseNumber: "0001",
                Trips__r: [
                    {
                        InfusionMonitoringArrivalTravelDate__c: "2025-04-05",
                        InfusionMonitoringReturnTravelDate__c: "2025-04-07"
                    }
                ]
            },
            {
                CaseNumber: "0002",
                Trips__r: [
                    {
                        InfusionMonitoringArrivalTravelDate__c: "2025-03-01",
                        InfusionMonitoringReturnTravelDate__c: "2025-05-10"
                    }
                ]
            },
            {
                CaseNumber: "0003",
                Trips__r: [
                    {
                        InfusionMonitoringArrivalTravelDate__c: null,
                        InfusionMonitoringReturnTravelDate__c: null
                    }
                ]
            }
        ];
    }
}
