import { LightningElement, track, wire } from 'lwc';
import getQueryResults from '@salesforce/apex/PSSTrackerCaseController.getQueryResults';
import getFilteredCases from '@salesforce/apex/PSSTrackerCaseController.getFilteredCases';
import getPSPTrackerConfig from '@salesforce/apex/PSSTrackerCaseController.getPSPTrackerConfig';
import { loadStyle } from 'lightning/platformResourceLoader';
import PATIENT_PORTAL_CSS from '@salesforce/resourceUrl/PatientPortal';
import saveRecord from '@salesforce/apex/PSSTrackerCaseController.saveRecord';
import { refreshApex } from '@salesforce/apex';

let filterLogic = {
    logic: "AND",
    filters: []
};
export default class Psp_PSSTracker_LWCComp extends LightningElement {

    /* Drop Down Options for autosuggestion */
    @track caseOwnerOptions = []; 
    @track treatmentCenterOptions = []; 
    @track coordinatorOptions = []; 

    /* Hold Selected options and value retention.*/ 
    @track selectedCaseOwnerIds = []; 
    @track selectedTreatmentCenterIds = []; 
    @track selectedCoordinatorIds = []; 
    @track selectedEnrollmentStatus = []; 
    @track selectedNextAction = [];

    /*Open flags when click on search text box.*/ 
    @track isCaseOwnerDropdownOpen = false; 
    @track isTreatmentCenterDropdownOpen = false; 
    @track isCoordinatorDropdownOpen = false; 
    @track isEnrollmentStatusDropdownOpen = false; 
    @track isNextActionStatusDropdownOpen = false;

    /* Trip date flags. */
    @track arrivalDate;
    @track departureDate;
    @track includeAllArrivalDates = false; 
    @track includeAllDepartureDates = false;

    /*Next action Dropdown Starts. */
    @track selectedNextActionDueDate = ''; 
    @track nextActionOptions = [
    { label: 'Begin Enrollment', value: 'Begin Enrollment' },
    { label: 'Eligibility Work Up', value: 'Eligibility Work Up' }];

    /**Enrolement Status options */
    @track enrollmentStatusOptions = [
        { label: 'New', value: 'New' },
        { label: 'Enrollment Information and Authorization Pending', value: 'Enrollment Information and Authorization Pending' },
        { label: 'Enrollment Information and Authorization Complete', value: 'Enrollment Information and Authorization Complete' },
        { label: 'Enrollment Process on Hold', value: 'Enrollment Process on Hold' },
        { label: 'Enrollment Process Cancelled', value: 'Enrollment Process Cancelled' }
    ];
    

    /* Loading and Error handling */
    @track isLoading = true;
    @track error; 

    /**Get autosuggestion options. */
    @wire(getQueryResults)
    wiredQueryResults({ error, data }) {
        if (data) {
            const parsedResult = JSON.parse(data);

            // Process CaseOwner options
            if (parsedResult.CaseOwner) {
                this.caseOwnerOptions = parsedResult.CaseOwner.map((item) => ({
                    label: item.label,
                    value: item.value,
                }));
            }

            // Process Treatment Center options
            if (parsedResult.TreatmentSite) {
                this.treatmentCenterOptions = parsedResult.TreatmentSite.map((item) => ({
                    label: item.label,
                    value: item.value,
                }));
            }

            // Process Coordinator options
            if (parsedResult.Coordinator) {
                this.coordinatorOptions = parsedResult.Coordinator.map((item) => ({
                    label: item.label,
                    value: item.value,
                }));
            }

            this.isLoading = false; 
        } else if (error) {
            console.error('Error fetching query results:', error);
            this.error = error; 
            this.isLoading = false; 
        }
    }

    connectedCallback() {
        Promise.all([
            loadStyle(this, PATIENT_PORTAL_CSS)]);
        this.filterType = 'MY_CASES';
        //this.fetchFilteredCases();
    }

    /* Handle click on the search box to open the dropdown. */
    handleSearchClick(event) {
        const dropdownType = event.target.dataset.type; 
        switch (dropdownType) {
            case 'caseOwner':
                this.isCaseOwnerDropdownOpen = !this.isCaseOwnerDropdownOpen;
                this.isTreatmentCenterDropdownOpen = false;
                this.isCoordinatorDropdownOpen =false;
                this.isEnrollmentStatusDropdownOpen =false;
                this.isNextActionStatusDropdownOpen = false;
                break;
            case 'TREATMENT_CENTER':
                this.isTreatmentCenterDropdownOpen = !this.isTreatmentCenterDropdownOpen;
                this.isCaseOwnerDropdownOpen = false;
                this.isCoordinatorDropdownOpen =false;
                this.isEnrollmentStatusDropdownOpen =false;
                this.isNextActionStatusDropdownOpen = false;
                break;
            case 'coordinator':
                this.isCoordinatorDropdownOpen = !this.isCoordinatorDropdownOpen;
                this.isTreatmentCenterDropdownOpen = false;
                this.isCaseOwnerDropdownOpen = false;
                this.isEnrollmentStatusDropdownOpen =false;
                this.isNextActionStatusDropdownOpen = false;
                break;
            case 'EnrollmentStatus':
                this.isEnrollmentStatusDropdownOpen = !this.isEnrollmentStatusDropdownOpen;
                this.isCoordinatorDropdownOpen = false;
                this.isTreatmentCenterDropdownOpen = false;
                this.isCaseOwnerDropdownOpen = false;
                this.isNextActionStatusDropdownOpen = false;
                break;
            case 'NEXT_ACTION':
                this.isNextActionStatusDropdownOpen = !this.isNextActionStatusDropdownOpen;
                this.isEnrollmentStatusDropdownOpen = false;
                this.isCoordinatorDropdownOpen = false;
                this.isTreatmentCenterDropdownOpen = false;
                this.isCaseOwnerDropdownOpen = false;
               
                break;
            default:
                console.warn(`Unknown dropdown type: ${dropdownType}`);
        }
        console.log('SURBHI ::',JSON.stringify(this.selectedCoordinatorIds));
    }

    /** Get the values from child component, sellected options for these cases. */
    handleSelectionChange(event) {
        const dropdownType = event.target.dataset.type; 
        const selectedValues = event.detail.selectedValues; 
        
        switch (dropdownType) {
            case 'caseOwner':
                this.selectedCaseOwnerIds = selectedValues;
                if(this.selectedCaseOwnerIds.length > 0){
                   // this.fetchFilteredCases();
                     this.isShowAllSelected = false;
                    refreshApex(this.wiredCasesResult);
                }else{
                    this.filterType = 'MY_CASES';
                    //this.fetchFilteredCases();
                    refreshApex(this.wiredCasesResult);
                }
                this.applyFilters();
                console.log('Selected Case Owner IDs:', this.selectedCaseOwnerIds);
                break;
            case 'TREATMENT_CENTER':
                this.selectedTreatmentCenterIds = selectedValues;
                this.includeAllTreatmentCenter = false;
                this.applyFilters();
                console.log('Selected Treatment Center IDs:', this.selectedTreatmentCenterIds);
                break;
            case 'coordinator':
                this.selectedCoordinatorIds = selectedValues;
                this.includeAllCoordinator = false;
                this.applyFilters();
                console.log('Selected Coordinator IDs:', this.selectedCoordinatorIds);
                break;
            case 'EnrollmentStatus':
                this.selectedEnrollmentStatus = selectedValues;
                this.includeAllEnrollmentStatus= false;
                this.applyFilters();
                console.log('Selected EnrollmentStatus IDs:', this.selectedEnrollmentStatus);
                break;
            case 'NEXT_ACTION':
                this.selectedNextAction = selectedValues;
                this.includeAllNextAction = false;
                this.applyFilters();
                console.log('Selected EnrollmentStatus IDs:', this.selectedNextAction);
                break;
            default:
                console.warn(`Unknown dropdown type: ${dropdownType}`);
        }
    }

    /* Handle selection in the Next Action Due Date picker. */
    handleNextActionDueDateChange(event) {
        this.selectedNextActionDueDate = event.target.value; 
        console.log('Selected Next Action Due Date:', this.selectedNextActionDueDate); 
        this.includeAllNextActionDueDate = false;
        this.isUnassignedClickedForNextActionDueDate = false;
        this.isThisWeekClickedForNextActionDueDate = false;
        this.todayDate = false;
        this.applyFilters();
    }

    /* Handle selection in the Trip Dates picker. */
    handleTripDatesChange(event) {
        const filterType = event.target.dataset.filter;
        const selectedDate = event.target.value;
    
        switch (filterType) {
            case 'ARRIVAL_DATE':
                this.arrivalDate = selectedDate;
                this.includeAllArrivalDates = true;
                console.log('Selected Arrival Date:', this.arrivalDate);
                break;
            case 'DEPARTURE_DATE':
                this.departureDate = selectedDate;
                this.includeAllDepartureDates = true;
                console.log('Selected Departure Date:', this.departureDate);
                break;
            default:
                console.warn('Unknown filter type:', filterType);
        }
        this.includeAllTripDates = false;
        this.applyFilters();
    }

    /**Button varient */
    get myCaseButton() {
        return   this.filterType == 'MY_CASES' ? 'brand' : '';
    }
    set myCaseButton(value) {
        return this.myCaseButton;
    }

    get allCaseButton() {
        return this.isShowAllSelected ? 'brand' : '';
    }

    /** Handle case button change. */
    @track filterType = 'MY_CASES';
    @track isShowAllSelected = false; 
    handleFilterChange(event) {
        const filter = event.target.dataset.filter;
        this.filterType = filter;

        this.isShowAllSelected = (this.filterType === 'ALL_CASES');
        if (this.isShowAllSelected) {
            this.selectedCaseOwnerIds = [];
            this.syncToChildComponent++;
        }

        if(this.filterType === 'MY_CASES'){
            this.myCaseButton = true;
            this.selectedCaseOwnerIds = [];
            this.syncToChildComponent ++;
        }else {
            this.myCaseButton = false;
        }
        filterLogic.filters = [];
        this.filtersLength = filterLogic.filters ? filterLogic.filters.length + (this.isShowAllSelected ? 1 : 0) : (this.isShowAllSelected ? 1 : 0);// Surbhi : Create  a filter logic object function and call where its used
        this.selectedCaseOwnerIds = []; 
        console.log('Filter Type Changed:', this.filterType);

        // Reset selected values for other filters when MY_CASES / ALL cASE is selected

        this.selectedNextAction = [];
        this.selectedNextActionDueDate = '';
        this.selectedTreatmentCenterIds = [];
        this.selectedEnrollmentStatus = [];
        this.arrivalDate = '';
        this.departureDate = '';
        this.selectedCoordinatorIds = []; 
        this.todayDate ='';
        this.selectedCaseOwnerIds = [];
        refreshApex(this.wiredCasesResult);
    }

    @track cases = [];
    @track _casesFiltered = []; 
    @track processedCases = []; /* Processed data variable used for render in table.*/

    @track paginatedCasesMap = new Map();
    currentPage = 1;

    get casesFiltered() {
        return this._casesFiltered;
    }
    
     /*  set casesFiltered(value) {
        this._casesFiltered = value;
        this.paginatedCasesMap = this.createPaginationMap(value); // Create a map for paginated data
        this.currentPage = 1; // Initialize to the first page
        this.updatePaginationState(); // Update the pagination state
    }*/

        @track initialSorting = false;
        @track sortedValue;
        set casesFiltered(value) {
             this.sortedValue = value;
            if(!this.initialSorting){
                this.sortedValue = this.customSortByNextActionFields([...value]);
                this.initialSorting = true; //add this attribute in clear all function
            }
            this._casesFiltered = this.sortedValue;
        
            this.paginatedCasesMap = this.createPaginationMap(this.sortedValue); // Create a map for paginated data
            this.currentPage = 1; // Initialize to the first page
            this.updatePaginationState(); // Update the pagination state
        }

    createPaginationMap(data) {
      //  data = this.customSortByNextActionFields(data); // Sort the data based on custom logic
        const itemsPerPage = 10; // Number of items per page
        const paginatedMap = new Map();
        const totalPages = Math.ceil(data.length / itemsPerPage);

        for (let i = 0; i < totalPages; i++) {
            const start = i * itemsPerPage;
            const end = start + itemsPerPage;
            paginatedMap.set(i + 1, data.slice(start, end));
        }

        return paginatedMap;
    }
    

    updatePaginationState() {
        const currentPageData = this.paginatedCasesMap.get(this.currentPage) || [];
        this.processedCases = this.preprocessTableData(currentPageData); // Preprocess data for the table
    }
    
    handlePrevious() {
        if (this.currentPage > 1) {
            this.currentPage--;
            this.updatePaginationState();
        }
    }

    handleNext() {
        if (this.currentPage < this.paginatedCasesMap.size) {
            this.currentPage++;
            this.updatePaginationState();
        }
    }

    handlePageClick(event) {
        const pageNumber = event.detail;
        this.currentPage = pageNumber;
        this.updatePaginationState();
    }

     wiredCasesResult;

     @wire(getFilteredCases, { 
        filterType: '$filterType', 
        caseOwnerIds: '$computedCaseOwnerIds' 
    })
    wiredCases(result) {
        this.wiredCasesResult = result; 
        const { data, error } = result;
        this.isLoading = true;
        if (data) {
            this.cases = data;
            this.casesFiltered = data;
            this.isLoading = false;
        } else if (error) {
            console.error('Error fetching filtered cases:', error);
            this.isLoading = false;
        }
    }

    get computedCaseOwnerIds() {
        return this.filterType === 'ALL_CASES' || this.filterType === 'MY_CASES'
            ? []
            : Array.isArray(this.selectedCaseOwnerIds)
            ? this.selectedCaseOwnerIds
            : [];
    }

    @track includeAllNextAction = false;
    @track includeAllNextActionDueDate = false;
    @track includeAllTreatmentCenter = false;
    @track includeAllEnrollmentStatus = false; 
    @track includeAllTripDates = false;
    @track includeAllCoordinator = false;

    @track isThisWeekClickedForNextActionDueDate = false;
    @track weekDaysArrayForNextActionDueDate = [];
    @track isUnassignedClickedForNextActionDueDate = false;

    @track syncToChildComponent = 0; // Surbhi : This is used to refresh the child component when the filter is applied. @track is used to make it reactive.
    @track todayDate = false;
    handleShowAll(event) {
        const filter = event.target.dataset.filter;
    
        switch (filter) {
            case 'NEXT_ACTION':
                this.selectedNextAction = [];
                this.includeAllNextAction = true;
                this.syncToChildComponent++;
                break;
            case 'NEXT_ACTION_DUE_DATE':
                this.selectedNextActionDueDate = '';
                this.todayDate= false;
                this.includeAllNextActionDueDate = true;
                this.isThisWeekClickedForNextActionDueDate = false;
                this.isUnassignedClickedForNextActionDueDate = false;
                break;
            case 'TREATMENT_CENTER':
                this.selectedTreatmentCenterIds = [];
                this.includeAllTreatmentCenter = true;
                this.syncToChildComponent++;
                break;
            case 'ENROLLMENT_STATUS':
                this.selectedEnrollmentStatus = [];
                this.includeAllEnrollmentStatus = true;
                this.syncToChildComponent++;
                break;
            case 'TRIP_DATES':
                this.includeAllArrivalDates = false;
                this.includeAllDepartureDates = false;
                this.arrivalDate = '';
                this.departureDate = '';
                this.includeAllTripDates = true;
                break;
            case 'COORDINATOR':
                this.selectedCoordinatorIds = [];
                this.includeAllCoordinator = true;
                this.syncToChildComponent++;
                break;
            case 'TODAY':
                this.selectedNextActionDueDate = new Date().toISOString().split('T')[0];
                this.todayDate = true;
                this.includeAllNextActionDueDate = false;
                this.isThisWeekClickedForNextActionDueDate = false;
                this.isUnassignedClickedForNextActionDueDate = false;
                break;
            case 'THIS_WEEK':
                this.isThisWeekClickedForNextActionDueDate = true;
                this.isUnassignedClickedForNextActionDueDate = false;
                this.selectedNextActionDueDate = '';
                this.weekDaysArrayForNextActionDueDate = this.getDatesThisWeek();
                this.includeAllNextActionDueDate = false;
                this.todayDate= false;
                break;
            case 'UNNASSIGNED':
                this.isThisWeekClickedForNextActionDueDate = false;
                this.isUnassignedClickedForNextActionDueDate = true;
                this.includeAllNextActionDueDate = false;
                this.todayDate= false;
                this.selectedNextActionDueDate = '';
                break;
            default:
                console.warn(`Unknown filter: ${filter}`);
        }

        console.log(`Reset filter for: ${filter}`);
        this.applyFilters();
    }

    /**Today May 1 , If I click the btn then it should give me April 27 to May 3 it will give those days. */
    getDatesThisWeek() {
        const today = new Date(); 
        const dates = [];
        
        // Calculate the start of the week (Sunday)
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - today.getDay()); // Set to the previous Sunday
    
        // Iterate through the entire week (Sunday to Saturday)
        for (let i = 0; i < 7; i++) {
            const currentDate = new Date(startOfWeek);
            currentDate.setDate(startOfWeek.getDate() + i);
            dates.push(currentDate.toISOString().split('T')[0]); // Add all days
        }
        return dates;
    }

    applyFilters() {
        const filters = [];
    
        /**Next Action Filter */
        if (this.includeAllNextAction) {
        } else if (this.selectedNextAction.length > 0) {
            filters.push({
                field: "NextAction__c",
                operator: "in",
                value: this.selectedNextAction
            });
        }
    
        /**Next Action Due Date Filter */
        if (this.includeAllNextActionDueDate) {
        } else if (this.selectedNextActionDueDate) {
            filters.push({
                field: "NextActionDueDate__c",
                operator: "Date",
                value: this.selectedNextActionDueDate
            });
        }else if (this.isThisWeekClickedForNextActionDueDate) {
            filters.push({
                field: "NextActionDueDate__c",
                operator: "Between",
                value: this.weekDaysArrayForNextActionDueDate
            });
        }else if (this.isUnassignedClickedForNextActionDueDate) {
            filters.push({
                field: "NextActionDueDate__c",
                operator: "includes",
                value: [null, '', undefined]
            });
        }
    
        /* Add Treatment Center filter. */
        if (this.includeAllTreatmentCenter) {
        } else if (this.selectedTreatmentCenterIds.length > 0) {
            filters.push({
                field: "TreatmentSite__c",
                operator: "in",
                value: this.selectedTreatmentCenterIds
            });
        }
    
        /* Add Enrollment Status filter. */
        if (this.includeAllEnrollmentStatus) {
        } else if (this.selectedEnrollmentStatus.length > 0) {
            filters.push({
                field: "EnrollmentStatus__c",
                operator: "includes",
                value: this.selectedEnrollmentStatus
            });
        }
    
        /* Add Trip Dates filter. */
        if (this.includeAllTripDates) {
        }

        if (this.arrivalDate && this.departureDate) {
            filters.push({
            field: "Trips__r",
                operator: "NestedBetween",
                startField: "InfusionMonitoringArrivalTravelDate__c",
                endField: "InfusionMonitoringReturnTravelDate__c",
                value: [this.arrivalDate, this.departureDate]
            });
        } else if (this.arrivalDate) {
            filters.push({
                field: "Trips__r",
                operator: "NestedDateEquals",
                startField: "InfusionMonitoringArrivalTravelDate__c",
                value: this.arrivalDate
            });
        } else if (this.departureDate) {
            filters.push({
                field: "Trips__r",
                operator: "NestedDateEquals",
                startField: "InfusionMonitoringReturnTravelDate__c",
                value: this.departureDate
            });
        }
    
        /* Add Coordinator filter. */
        if (this.includeAllCoordinator) {
        } else if (this.selectedCoordinatorIds.length > 0) {
            filters.push({
                field: "OrderID__r.Coordinator__c",
                operator: "in",
                value: this.selectedCoordinatorIds
            });
        }

        console.log('this.coordinators -->'+ JSON.stringify(this.coordinatorOptions)+'   '+"this.tcc-->"+ JSON.stringify(this.treatmentCenterOptions));
        filterLogic = {
            logic: "AND",
            filters: filters
        };
        this.filtersLength = filterLogic.filters ? filterLogic.filters.length + (this.isShowAllSelected ? 1 : 0) : (this.isShowAllSelected ? 1 : 0);
        console.log('Filter Logic:', JSON.stringify(filterLogic, null, 2)); 
        this.casesFiltered = this.cases.filter(caseItem => {
            return filters.every(filter => this.evaluateField(caseItem, filter));
        });
    }
    evaluateField(record, filter) {
        if (filter.operator === "NestedBetween") {
            return this.matchNestedDateRange(record[filter.field], filter);
        } else if (filter.operator === "NestedDateEquals") {
            return this.matchNestedDateEquals(record[filter.field], filter);
        } else {
            const path = filter.field.split('.');
            return this.resolvePath(record, path, filter);
        }
    }
                
    resolvePath(obj, pathArr, filter) {
        const key = pathArr[0];

        if (Array.isArray(obj)) {
            return obj.some(item => this.resolvePath(item, pathArr, filter));
        }

        if (pathArr.length === 1) {
            const value = obj?.[key];

            if (Array.isArray(value)) {
                return value.some(item => this.matchFilter(item, filter));
            }

            return this.matchFilter(value, filter);
        }
        const next = obj?.[key];
        if (Array.isArray(next)) {
            return next.some(item => this.resolvePath(item, pathArr.slice(1), filter));
        }

        return this.resolvePath(next, pathArr.slice(1), filter);
    }
                
    matchFilter(value, filter) {
        switch (filter.operator) {
            case "in":
            case "includes":
                return filter.value.includes(value);

            case "equals":
                return value === filter.value;

            case "Date":
                if (!value) return false;
                return this.formatDateOnly(value) === this.formatDateOnly(filter.value);

            case "Between":
                if (!value) return false;
                const valDate = new Date(this.formatDateOnly(value));
                const [start, end] = filter.value.map(v => new Date(this.formatDateOnly(v)));
                return valDate >= start && valDate <= end;

            default:
                return true;
        }
    }
        
    /**Calculate nested date range for arrival and departure date range. */
    matchNestedDateRange(array, filter) {
        if (!array || !Array.isArray(array)) return false;

        const [startDate, endDate] = filter.value.map(v => new Date(this.formatDateOnly(v)));

        return array.some(item => {
            let match = false;
            if (item[filter.startField]) {
                const valStart = new Date(this.formatDateOnly(item[filter.startField]));
                match = match || (valStart >= startDate && valStart <= endDate);
            }
            if (item[filter.endField]) {
                const valEnd = new Date(this.formatDateOnly(item[filter.endField]));
                match = match || (valEnd >= startDate && valEnd <= endDate);
            }
            return match;
        });
    }
        
    /**Calculate nested date equals for arrival and departure date range. */
    matchNestedDateEquals(array, filter) {
        const targetDate = this.formatDateOnly(filter.value);
        return array?.some(item => {
            const dateVal = item[filter.startField];
            return dateVal && this.formatDateOnly(dateVal) === targetDate;
        });
    }

    /**Remove the time zone if already esists. */
    formatDateOnly(date) {
        return new Date(date).toISOString().split('T')[0];
    }
                
    @track _filtersLength = ''; // Surbhi : This is used to show the number of filters applied in the UI.

    get filtersLength() {
       
        return this._filtersLength;
    }

    set filtersLength(value) {
        if (value === undefined || value === null) {
            return ;
        }
        if (value <= 0) {
            this._filtersLength = '';
        }else{
            this._filtersLength = '(' + value + ')';
        }
    }

    clearAllFilters() {
        this.isDefultSortingRan = false;
        this.filterType = 'MY_CASES';
        this.isShowAllSelected = false;
        filterLogic = {
            logic: "AND",
            filters: null 
        };
        this.filtersLength = filterLogic.filters ? filterLogic.filters.length + (this.isShowAllSelected ? 1 : 0) : (this.isShowAllSelected ? 1 : 0);
         this.selectedCaseOwnerIds = [];
         this.selectedNextAction = [];
         this.selectedNextActionDueDate = '';
         this.selectedTreatmentCenterIds = [];
         this.selectedEnrollmentStatus = [];
         this.arrivalDate = '';
         this.departureDate = '';
         this.selectedCoordinatorIds = []; 

         this.includeAllNextAction = false;
         this.includeAllNextActionDueDate = false;
         this.todayDate =false;
         this.isThisWeekClickedForNextActionDueDate =false;
         this.isUnassignedClickedForNextActionDueDate  =false;
         this.includeAllTripDates =false;
         this.includeAllTreatmentCenter = false;

         this.includeAllArrivalDates = false;
         this.includeAllDepartureDates = false;
         this.arrivalDate = '';
         this.departureDate = '';

         this.includeAllEnrollmentStatus =false;
         this.includeAllCoordinator = false;
         this.initialSorting = false;
         refreshApex(this.wiredCasesResult);
         this.applyFilters();
         this.syncToChildComponent++;
    }

    columnConfig = [];
    objectName = 'Case'; // Default object name, can be updated dynamically

    @wire(getPSPTrackerConfig, { objectName: '$objectName' })
    wiredColumnConfig({ error, data }) {
        if (data) {
            this.columnConfig = data
                .map(config => ({
                    column_id: config.column_id,
                    label: config.label,
                    data_type: config.data_type,
                    visible: config.visible,
                    editable: config.editable,
                    isString: config.isString,
                    isNumber: config.isNumber,
                    isDate: config.isDate,
                    isPicklist: config.isPicklist,
                    picklist_values: config.picklist_values
                        ? config.picklist_values[0].split(',').map(value => value.trim())
                        : [],
                    isSortingApplied: config.isSortingApplied,
                    sortDirection: config.sortDirection,
                    IsAscsortDirection: config.IsAscsortDirection,
                    IsDescsortDirection: config.IsDescsortDirection,
                    PSSViewColumnOrder: config.PSSViewColumnOrder ,// Add the order field
                    IsDefaultColumnSort: config.IsDefaultColumnSort ,
                    ColumnWidth : [null, '', undefined].includes(config.ColumnWidth) ? '' : this.abc(config.ColumnWidth)
                }))
                .sort((a, b) => {
                    // Primary sorting by PSSViewColumnOrder
                    if (a.PSSViewColumnOrder !== b.PSSViewColumnOrder) {
                        return a.PSSViewColumnOrder - b.PSSViewColumnOrder;
                    }
                    // Secondary sorting by column_id (or any other field)
                    return a.column_id.localeCompare(b.column_id);
                });
    
            console.log('Column Config (sorted):', JSON.stringify(this.columnConfig));
        } else if (error) {
            console.error('Error fetching PSP Tracker Config:', error);
        }
    }

    abc(cssString){
        this.injectCSS(cssString);
        console.log('column-width:', cssString);
        const classNames = cssString.match(/\.(\w[\w-]*)/g);
        // Remove the leading dot (.) from each class name and join them into a single string
        return classNames ? classNames.map(className => className.slice(1)).join(' ') : '';
    }

    injectCSS(cssString) {
        const style = document.createElement('style');
        style.textContent = cssString;
        this.template.querySelector('head')?.appendChild(style) || document.head.appendChild(style);
    }

    customSortByNextActionFields(cases) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
    
        const isEmpty = val => val === null || val === undefined || val === '' || String(val).trim() === '';
    
        return cases.sort((a, b) => {
            const aEmpty = isEmpty(a.NextAction__c) && isEmpty(a.NextActionDueDate__c);
            const bEmpty = isEmpty(b.NextAction__c) && isEmpty(b.NextActionDueDate__c);
    
            if (aEmpty && !bEmpty) return -1;
            if (!aEmpty && bEmpty) return 1;
    
            const aDueDate = a.NextActionDueDate__c ? new Date(a.NextActionDueDate__c) : null;
            const bDueDate = b.NextActionDueDate__c ? new Date(b.NextActionDueDate__c) : null;
    
            const aFuture = aDueDate && aDueDate > today;
            const bFuture = bDueDate && bDueDate > today;
    
            if (aFuture && !bFuture) return -1;
            if (!aFuture && bFuture) return 1;
    
            return 0; // maintain original order if all else is equal
        });
    }
        preprocessTableData(cases) {
           // const sortedCases = this.sortTableData(cases, this.columnConfig);
        //   const sortedCases = this.customSortByNextActionFields(cases);
   
            return cases.map(row => {
                const updatedRow = { 
                    ...row, 
                    columns: [], 
                    showContent: false,
                    isExpanded: false,
                    detailRowKey: `${row.Id}-details`
                };
        
                this.columnConfig.forEach(column => {
                    if (column.visible) {
                        const fieldParts = column.column_id.split('.');
                        let fieldValue = row;
                        for (const part of fieldParts) {
                            fieldValue = fieldValue ? fieldValue[part] : undefined;
                        }
        
                        let value = fieldValue;
                        let isHyperlink = false;
                        let cellClass = ''; 
                        

                        if (column.column_id === 'NextActionDueDate__c') {
                            const dueDate = fieldValue ? new Date(fieldValue) : null;
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                        
                            if (dueDate && dueDate > today) {
                                cellClass = 'highlight-red'; // Highlight red for future dates
                            } else if ([null, '', undefined].includes(fieldValue)) {
                                cellClass = 'highlight-yellow'; // Highlight yellow for blank or undefined
                            }
                        }

                        if (column.column_id === 'NextAction__c') {
                            if ([null, '', undefined].includes(fieldValue)) {
                                cellClass = 'highlight-yellow'; // Highlight yellow for blank or undefined
                            }
                        }
        
                        // Add hyperlink logic for specific columns
                        if (column.column_id === 'Account.Name') {
                            value = `<span class="patient-name">${fieldValue}</span></br><a href="/lightning/r/Case/${row.Id}/view" target="_blank">${row.CaseNumber}</a>`;
                            isHyperlink = true;
                        } else if (column.column_id === 'CartCoordinatorName__c') {
                            value = [null, '', undefined].includes(fieldValue) 
                            ? '' 
                            : fieldValue.includes('_self') 
                                ? fieldValue.replace('_self', '_blank') : fieldValue;  
                            isHyperlink = true;
                        } else if (column.column_id === 'TreatmentCenterName__c') {
                            value = `<a href="/lightning/r/Account/${row.TreatmentSite__c}/view" target="_blank">${fieldValue}</a>`;
                            isHyperlink = true;
                        }
        
                        updatedRow.columns.push({
                            field: column.column_id.toLowerCase(),
                            label: column.label,
                            value: value,
                            isHyperlink: isHyperlink,
                            dataType: column.data_type,
                            isEditing: false,
                            isEditable: column.editable || false,
                            isString: column.isString || false,
                            isNumber: column.isNumber || false,
                            isDate: column.isDate || false,
                            isPicklist: column.isPicklist || false,
                            options: column.isPicklist ? column.picklist_values.map(value => ({ label: value, value })) : null,
                            cellClass : cellClass
                        });
                    }
                });
        
                return updatedRow;
            });
        }
    
    resolveNestedField(obj, pathArr) {
        let value = obj;
        for (const part of pathArr) {
            if (value === undefined || value === null) {
                return undefined;
            }
            value = value[part];
        }
        return value;
    }

    @track isDefultSortingRan = false;
    /**Defult sorting as per column config. */
    sortTableData(cases, columnConfig) {
        // Validate inputs
        if(!this.isDefultSortingRan){
            console.log('Sorting cases based on columnConfig:');
        if (!Array.isArray(cases)) {
            console.error('Invalid input: "cases" must be an array.');
            return [];
        }
        if (!Array.isArray(columnConfig)) {
            console.error('Invalid input: "columnConfig" must be an array.');
            return cases;
        }
    
        // Find the column with IsDefaultColumnSort set to true
        const defaultSortColumn = columnConfig.find(column => column.IsDefaultColumnSort);
        if (!defaultSortColumn) {
            console.warn('No column with IsDefaultColumnSort set to true found.');
            return cases; // No sorting required
        }
    
        // Extract column_id and sortDirection from the default sort column
        let { column_id, sortDirection } = defaultSortColumn;
    
        // Normalize sortDirection
        sortDirection = sortDirection ? sortDirection.toLowerCase() : 'asc';
        if (!['asc', 'desc'].includes(sortDirection)) {
            console.error(`Invalid sortDirection: "${sortDirection}". Defaulting to "asc".`);
            sortDirection = 'asc';
        }
        const isAscending = sortDirection === 'asc';
    
        // Clone the cases array to avoid modifying the original array
        const casesClone = [...cases];
        this.isDefultSortingRan = true;
        return casesClone.sort((a, b) => {
            const fieldParts = column_id.split('.');
            let valueA = a;
            let valueB = b;
    
            // Traverse nested fields
            for (const part of fieldParts) {
                valueA = valueA ? valueA[part] : undefined;
                valueB = valueB ? valueB[part] : undefined;
            }
    
            // Handle undefined or null values
            if (valueA === valueB) return 0;
            if (valueA === undefined || valueA === null) return isAscending ? -1 : 1;
            if (valueB === undefined || valueB === null) return isAscending ? 1 : -1;
    
            // Compare values based on sort order
            try {
                return isAscending
                    ? valueA.toString().localeCompare(valueB.toString())
                    : valueB.toString().localeCompare(valueA.toString());
            } catch (error) {
                console.error('Error comparing values:', error);
                return 0; // Fallback to no change in order
            }
        });
  
    }else {
        return cases;    
    }
}

    @track editedValues = {}; // Stores temp edits
    handleRowAction(event) {
        const rowId = event.target.dataset.id;
        this.processedCases = this.processedCases.map(row => ({
            ...row,
            isExpanded: row.Id === rowId ? !row.isExpanded : row.isExpanded,
            showContent: row.Id === rowId ? !row.showContent : row.showContent
        }));
    }
    
    handleEditClick(event) {
        const rowId = event.target.dataset.id;
        const field = event.target.dataset.field;

        this.processedCases = this.processedCases.map(row => {
            if (row.Id === rowId) {
                return {
                    ...row,
                    isEditing: true, // Set row to editing mode
                    detailRowKeyForSaveAndCancel: `${row.Id}-save-cancel`, // Add key for Save and Cancel row
                    columns: row.columns.map(col => ({
                        ...col,
                        isEditing: col.field === field
                    }))
                };
            }
            return {
                ...row,
                isEditing: false, // Ensure other rows are not in editing mode
                detailRowKeyForSaveAndCancel: null, // Clear Save and Cancel row key for other rows
                columns: row.columns.map(col => ({
                    ...col,
                    isEditing: false
                }))
            };
        });
    }
    
    handleInputChange(event) {
        const rowId = event.target.dataset.id;
        const field = event.target.dataset.field;
        const value = event.target.value;
    
        if (!this.editedValues[rowId]) {
            this.editedValues[rowId] = {};
        }
        this.editedValues[rowId][field] = value;
    }
    
    async handleSave(event) {
        const rowId = event.target.dataset.id;  // Get recordId from the event

        const updatedRow = this.processedCases.find(row => row.Id === rowId);
        if (!updatedRow) {
            console.warn(`No row found with rowId: ${rowId}`);
            return;
        }

        const updatedValues = this.editedValues[rowId];

        // Prepare the payload for the Apex method
        const payload = {
            recordId: rowId,
            objectApiName: updatedRow.objectApiName || 'Case',  // Use the objectApiName dynamically
            fieldName: Object.keys(updatedValues)[0],  // Get the first field to update (can be expanded to multiple fields)
            updatedValue: updatedValues[Object.keys(updatedValues)[0]]  // Get the updated value
        };

        console.log('Payload to send to backend:', JSON.stringify(payload));

        try {
            // Call Apex method to update the record
            await saveRecord({ payload });

            console.log(`Record with rowId: ${rowId} saved successfully.`);

            // Update the UI after successful save
            this.processedCases = this.processedCases.map(row => {
                if (row.Id === rowId) {
                    return {
                        ...row,
                        isEditing: false,  // Exit editing mode
                        detailRowKeyForSaveAndCancel: null,  // Clear Save/Cancel row key
                        columns: row.columns.map(col => ({
                            ...col,
                            value: updatedValues[col.field] ?? col.value,  // Update column value with the new data
                            isEditing: false,  // Reset editing state
                            cellClass: col.field === Object.keys(updatedValues)[0] ? '' : col.cellClass // Reset cellClass only for the updated field
                        }))
                    };
                }
                return row;
            });

            // Remove the edited values after save
            delete this.editedValues[rowId];

        } catch (error) {
            console.error(`Error saving record with rowId: ${rowId}`, error);
        }
    }  
    
    handleCancel(event) {
        const rowId = event.target.dataset.id;
        delete this.editedValues[rowId];
    
        this.processedCases = this.processedCases.map(row => {
            if (row.Id === rowId) {
                return {
                    ...row,
                    isEditing: false, // Exit editing mode
                    detailRowKeyForSaveAndCancel: null, // Clear Save and Cancel row key
                    columns: row.columns.map(col => ({
                        ...col,
                        isEditing: false
                    }))
                };
            }
            return row;
        });
    }
    
    handleSort(event) {
        const columnId = event.target.dataset.columnId; // Get the column ID
        console.log('Sorting triggered for column:', columnId);
    
        const columnConfig = this.columnConfig.find(col => col.column_id === columnId);
        console.log('Column configuration before sorting:', JSON.stringify(columnConfig));
    
        if (columnConfig && columnConfig.isSortingApplied) {
            // Toggle sort direction
            if (columnConfig.sortDirection === 'asc') {
                columnConfig.sortDirection = 'desc';
                columnConfig.IsAscsortDirection = false;
                columnConfig.IsDescsortDirection = true;
                console.log('Sort direction changed to DESC');
            } else {
                columnConfig.sortDirection = 'asc';
                columnConfig.IsAscsortDirection = true;
                columnConfig.IsDescsortDirection = false;
                console.log('Sort direction changed to ASC');
            }
    
            console.log('Updated column configuration:', JSON.stringify(columnConfig));
    
            // Sort the processedCases array dynamically based on sortDirection
            const sortDirection = columnConfig.sortDirection;
            const isDate = columnConfig.data_type === 'date';
            const isNumber = columnConfig.data_type === 'number';
    
            console.log('Sorting details:', {
                sortDirection,
                isDate,
                isNumber,
            });
    
                this.casesFiltered  = [...this.casesFiltered].sort((a, b) => {
                const fieldParts = columnId.split('.');
                let aValue = a;
                let bValue = b;
    
                // Resolve nested fields dynamically
                for (const part of fieldParts) {
                    aValue = aValue ? aValue[part] : undefined;
                    bValue = bValue ? bValue[part] : undefined;
                }
    
                console.log('Resolved values for comparison:', { aValue, bValue });
    
                if (isDate) {
                    aValue = new Date(aValue);
                    bValue = new Date(bValue);
                    console.log('Converted values to Date:', { aValue, bValue });
                }
    
                if (isNumber) {
                    aValue = parseFloat(aValue);
                    bValue = parseFloat(bValue);
                    console.log('Converted values to Number:', { aValue, bValue });
                }
    
                if (sortDirection === 'asc') {
                    return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;
                } else {
                    return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;
                }
            });

            console.log('Processed cases after sorting:', JSON.stringify(this.processedCases));
        } else {
            console.error('Column configuration not found for columnId:', columnId);
        }
    }

    get computedColspan() {
        console.log('Column Config Length:', this.columnConfig.length);
        return this.columnConfig.length; // +1 for the action column
    }

    openCloseFilterSection(event){
        event.currentTarget.parentNode.parentNode.parentNode.classList.toggle("slds-is-open");
        let icon = event.currentTarget.iconName;
        event.currentTarget.iconName = icon === 'utility:chevrondown' ? 'utility:chevronup' : 'utility:chevrondown';
    }

    handleRefresh() {
        refreshApex(this.wiredCasesResult);
        console.log('Refresh called', filterLogic.filters);
    
        this.casesFiltered = this.cases.filter(caseItem => {
            return filterLogic.filters.every(filter => {
                return this.evaluateField(caseItem, filter);
            });
        });
    }

    get nextActionShowAllButton(){
        return this.includeAllNextAction ? 'brand' : '';
    }

    get allNextActionDueDateButton(){
        return this.includeAllNextActionDueDate ? 'brand' : '';
    }

    get getTodayShowAllButton(){
        return this.todayDate  ? 'brand' : '';
    }

    get getThisWeekButton(){
        return this.isThisWeekClickedForNextActionDueDate  ? 'brand' : '';
    }

    get getUnassignedButton(){
        return this.isUnassignedClickedForNextActionDueDate  ? 'brand' : '';
    }

    get getAllTripDatesButton(){
        return this.includeAllTripDates  ? 'brand' : '';
    }
    get getAllTreatmentCenterButton(){
        return this.includeAllTreatmentCenter  ? 'brand' : '';
    }
    get getAllCoordinatorButton(){
        return this.includeAllCoordinator  ? 'brand' : '';
    }
    get getAllEnrollmentStatusButton(){
        return this.includeAllEnrollmentStatus  ? 'brand' : '';
    }
}
