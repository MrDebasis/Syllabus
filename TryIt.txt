const CHUNK_SIZE = 750 * 1024;
        handleFileChange(event) {
            const file = event.target.files[0];
            if (!file) return;
    
            const allowedFileTypes = ["heic", "jpeg", "jpg", "png", "pdf"];
            const fileExtension = file.name.split(".").pop().toLowerCase();
    
            if (!allowedFileTypes.includes(fileExtension)) {
                this.showErrorMessage("Invalid file type!", true);
                return;
            }
    
            if (file.size > 10 * 1024 * 1024) {
                this.showErrorMessage("File size exceeds 10 MB!", true);
                return;
            }
    
            this.showErrorMessage("", false);
            this.readFile(file);
        }

        readFile(file) {
            const fileReader = new FileReader();
    
            fileReader.onload = () => {
                const base64 = fileReader.result.split(",")[1]; // Remove metadata
                this.uploadInChunks(file.name, base64, file.type);
            };
    
            fileReader.onerror = () => {
                this.showErrorMessage("File reading error!", true);
            };
    
            fileReader.readAsDataURL(file);
        }
    
        uploadInChunks(fileName, base64Data, contentType) {
            this.isLoading = true;
            let startPosition = 0;
            let endPosition = Math.min(CHUNK_SIZE, base64Data.length);
            let contentVersionId = null; // Now using ContentVersionId instead of ContentDocumentId
        
            const uploadChunk = () => {
                const chunk = base64Data.substring(startPosition, endPosition);
        
                uploadChunkToContentDocument({
                    fileName: fileName,
                    base64Chunk: chunk,
                    contentType: contentType,
                    isLastChunk: endPosition >= base64Data.length,
                    contentVersionId: contentVersionId // Track ContentVersionId, not ContentDocumentId
                })
                .then((returnedId) => {
                    contentVersionId = returnedId; // Store the ID after the first chunk
                 console.log('returnedId--->',returnedId);
                    if (endPosition < base64Data.length) {
                        startPosition = endPosition;
                        endPosition = Math.min(startPosition + CHUNK_SIZE, base64Data.length);
                        uploadChunk(); // Upload next chunk
                    } else {
                        this.uploadedFileIds.push(contentVersionId);
                        this.showSuccessMessage("File uploaded successfully!");
                        this.isLoading = false;
                    }
                })
                .catch((error) => {
                    console.error("Error uploading chunk:", error);
                    this.showErrorMessage("File upload failed!", true);
                    this.isLoading = false;
                });
            };
        
            uploadChunk(); // Start chunked upload
        }
    
        showErrorMessage(message, show = true) {
            // Replace this with your actual error handling
            if (show) {
                alert("Error: " + message);
            }
        }
    
        showSuccessMessage(message) {
            // Replace this with your actual success handling
            alert(message);
        }
