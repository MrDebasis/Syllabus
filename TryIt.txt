import { LightningElement, track } from 'lwc';

export default class CaseFilter extends LightningElement {
    @track cases = []; // full data
    @track casesFiltered = []; // filtered output
    @track filtersLength = 0;

    connectedCallback() {
        this.cases = this.mockCases(); // Load sample data
        this.applyFilters();
    }

    applyFilters() {
        const filters = [
            {
                field: "EnrollmentStatus__c",
                operator: "in",
                value: ["Enrolled", "Pending"]
            },
            {
                field: "TreatmentSite__c",
                operator: "equals",
                value: "TS001"
            },
            {
                field: "InfusionAppointmentDate__c",
                operator: "Date",
                value: "2025-04-15"
            },
            {
                field: "Trips__r.InfusionMonitoringArrivalTravelDate__c",
                operator: "nestedBetween",
                value: ["2007-04-12", "2063-04-05"]
            }
        ];

        this.filtersLength = filters.length;

        this.casesFiltered = this.cases.filter(record => {
            return filters.every(filter => this.evaluateField(record, filter));
        });

        console.log("âœ… Filtered Output:", this.casesFiltered);
    }

    evaluateField(record, filter) {
        const path = filter.field.split('.');
        return this.resolvePath(record, path, filter);
    }

    resolvePath(obj, pathArr, filter) {
        const key = pathArr[0];

        if (Array.isArray(obj)) {
            return obj.some(item => this.resolvePath(item, pathArr, filter));
        }

        if (pathArr.length === 1) {
            const value = obj?.[key];

            // Handle normal and array fields
            if (Array.isArray(value)) {
                if (filter.operator === "nestedBetween") {
                    return value.some(item => this.matchFilter(item, {
                        ...filter,
                        operator: "Between" // Convert nestedBetween to Between
                    }));
                }
                return value.some(item => this.matchFilter(item, filter));
            }

            return this.matchFilter(value, filter);
        }

        const next = obj?.[key];

        if (Array.isArray(next)) {
            return next.some(item => this.resolvePath(item, pathArr.slice(1), filter));
        }

        return this.resolvePath(next, pathArr.slice(1), filter);
    }

    matchFilter(value, filter) {
        switch (filter.operator) {
            case "in":
            case "includes":
                return filter.value.includes(value);

            case "equals":
                return value === filter.value;

            case "Date":
                if (!value) return false;
                return new Date(value).toISOString().split('T')[0] === new Date(filter.value).toISOString().split('T')[0];

            case "Between":
                if (!value) return false;
                const valDate = new Date(value);
                const [start, end] = filter.value.map(v => new Date(v));
                return valDate >= start && valDate <= end;

            default:
                return true;
        }
    }

    // Sample Data
    mockCases() {
        return [
            {
                EnrollmentStatus__c: "Enrolled",
                TreatmentSite__c: "TS001",
                InfusionAppointmentDate__c: "2025-04-15",
                Trips__r: [
                    {
                        InfusionMonitoringArrivalTravelDate__c: "2025-04-10",
                        InfusionMonitoringReturnTravelDate__c: "2025-04-20"
                    }
                ]
            },
            {
                EnrollmentStatus__c: "Declined",
                TreatmentSite__c: "TS002",
                InfusionAppointmentDate__c: "2025-05-01",
                Trips__r: [
                    {
                        InfusionMonitoringArrivalTravelDate__c: "2026-01-01",
                        InfusionMonitoringReturnTravelDate__c: "2026-01-05"
                    }
                ]
            }
        ];
    }
}
