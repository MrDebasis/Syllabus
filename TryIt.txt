<template>
    <!-- Screen 1 -->
    <template if:true={isScreen1}>
        <template for:each={screen1Questions} for:item="q">
            <div key={q.apiName} class="s-question">
                <label>{q.label}</label>

                <template if:true={isDateType(q)}>
                    <lightning-input 
                        type="date"
                        data-id={q.apiName}
                        onchange={handleInputChange}
                        required={q.required}>
                    </lightning-input>
                </template>

                <template if:true={isPicklistType(q)}>
                    <lightning-combobox
                        data-id={q.apiName}
                        onchange={handleInputChange}
                        options={getPicklistOptions(q.options)}
                        required={q.required}>
                    </lightning-combobox>
                </template>
            </div>
        </template>
    </template>

    <!-- Placeholder content for Screens 2â€“5 -->
    <template if:true={isScreen2}><div>Screen 2 Content</div></template>
    <template if:true={isScreen3}><div>Screen 3 Content</div></template>
    <template if:true={isScreen4}><div>Screen 4 Content</div></template>
    <template if:true={isScreen5}><div>Screen 5 Content</div></template>

    <!-- Navigation Buttons -->
    <lightning-button label="Back" onclick={handleBack} disabled={currentScreen === 1}></lightning-button>
    <lightning-button label="Next" onclick={handleNext} disabled={isNextDisabled}></lightning-button>
</template>


import { LightningElement, track } from 'lwc';

export default class MultiScreenSurvey extends LightningElement {
    @track currentScreen = 1;
    @track answers = {};
    @track isNextDisabled = true;

    // Question Config
    surveyConfig = {
        "1": [
            {
                "apiName": "apheresis_appointment_date",
                "label": "When is the apheresis appointment date for Order # [Order Number]?*",
                "required": true,
                "type": "Date"
            },
            {
                "apiName": "apheresis_appointment",
                "label": "What day should the patient arrive for their apheresis appointment?*",
                "required": true,
                "type": "Date"
            },
            {
                "apiName": "patient_depart",
                "label": "What day should the patient depart?*",
                "required": true,
                "type": "Date"
            }
        ]
    };

    // Screen flags
    get isScreen1() {
        return this.currentScreen === 1;
    }
    get isScreen2() {
        return this.currentScreen === 2;
    }
    get isScreen3() {
        return this.currentScreen === 3;
    }
    get isScreen4() {
        return this.currentScreen === 4;
    }
    get isScreen5() {
        return this.currentScreen === 5;
    }

    // Get questions for screen 1
    get screen1Questions() {
        return this.surveyConfig["1"];
    }

    handleInputChange(event) {
        const field = event.target.dataset.id;
        const value = event.target.value;
        this.answers[field] = value;

        this.validateRequired();
    }

    validateRequired() {
        const requiredQuestions = this.screen1Questions.filter(q => q.required);
        const allAnswered = requiredQuestions.every(q => {
            const val = this.answers[q.apiName];
            return val !== undefined && val !== '';
        });

        this.isNextDisabled = !allAnswered;
    }

    handleNext() {
        if (this.currentScreen < 5) {
            this.currentScreen++;
            this.isNextDisabled = false; // Reset for next screen
        }
    }

    handleBack() {
        if (this.currentScreen > 1) {
            this.currentScreen--;
            this.validateRequired(); // Re-check validation
        }
    }

    isDateType(q) {
        return q.type === 'Date';
    }

    isPicklistType(q) {
        return q.type === 'Picklist';
    }

    getPicklistOptions(optionsStr) {
        return optionsStr?.split(',').map(opt => ({
            label: opt.trim(),
            value: opt.trim()
        })) || [];
    }
}
