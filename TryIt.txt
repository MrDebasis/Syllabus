const CHUNK_SIZE = 750 * 1024;

handleFileChange(event) {
    const file = event.target.files[0];
    if (!file) return;

    const allowedFileTypes = ["heic", "jpeg", "jpg", "png", "pdf"];
    const fileExtension = file.name.split(".").pop().toLowerCase();

    if (!allowedFileTypes.includes(fileExtension)) {
        this.showErrorMessage("Invalid file type!", true);
        return;
    }

    if (file.size > 10 * 1024 * 1024) {
        this.showErrorMessage("File size exceeds 10 MB!", true);
        return;
    }

    this.showErrorMessage("", false);
    this.readFile(file);
}

readFile(file) {
    const fileReader = new FileReader();

    fileReader.onload = () => {
        const base64 = fileReader.result.split(",")[1]; // Remove metadata
        this.uploadInChunks(file.name, base64, file.type);
    };

    fileReader.onerror = () => {
        this.showErrorMessage("File reading error!", true);
    };

    fileReader.readAsDataURL(file);
}

uploadInChunks(fileName, base64Data, contentType) {
    this.isLoading = true;
    let startPosition = 0;
    let endPosition = Math.min(CHUNK_SIZE, base64Data.length);
    let contentVersionId = null; // This will be set to the ContentVersionId from the API response

    const uploadChunk = () => {
        const chunk = base64Data.substring(startPosition, endPosition);

        // Pass the current contentVersionId along with the chunk
        this.uploadChunkToSalesforce({
            fileName: fileName,
            base64Chunk: chunk,
            contentType: contentType,
            isLastChunk: endPosition >= base64Data.length,
            contentVersionId: contentVersionId // Pass the correct ContentVersionId
        })
        .then((returnedId) => {
            if (!contentVersionId && returnedId) {
                // On first chunk, set the contentVersionId
                contentVersionId = returnedId;
                console.log('First ContentVersionId:', contentVersionId); // Debug log
            }
            if (endPosition < base64Data.length) {
                startPosition = endPosition;
                endPosition = Math.min(startPosition + CHUNK_SIZE, base64Data.length);
                uploadChunk(); // Upload next chunk
            } else {
                this.uploadedFileIds.push(contentVersionId);
                this.showSuccessMessage("File uploaded successfully!");
                this.isLoading = false;
            }
        })
        .catch((error) => {
            console.error("Error uploading chunk:", error);
            this.showErrorMessage("File upload failed!", true);
            this.isLoading = false;
        });
    };

    uploadChunk(); // Start chunked upload
}

uploadChunkToSalesforce({ fileName, base64Chunk, contentType, isLastChunk, contentVersionId }) {
    const url = '/services/data/v50.0/sobjects/ContentVersion/';
    const body = {
        Title: fileName,
        PathOnClient: fileName,
        VersionData: base64Chunk,
        IsMajorVersion: true,
    };

    // If we have a contentVersionId, we update it with the new chunk.
    if (contentVersionId) {
        body['ContentVersionId'] = contentVersionId;
    }

    return fetch(url, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${sessionStorage.getItem('access_token')}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
    })
    .then(response => response.json())
    .then(result => {
        console.log('File uploaded, ContentVersionId:', result.id);
        return result.id; // Return ContentVersionId for next chunk
    })
    .catch((error) => {
        console.error("Error uploading chunk:", error);
        throw new Error("File upload failed!");
    });
}

showErrorMessage(message, show = true) {
    if (show) {
        alert("Error: " + message);
    }
}

showSuccessMessage(message) {
    alert(message);
}
