import { LightningElement, track } from 'lwc';

export default class CaseFilter extends LightningElement {
    @track cases = []; // full data
    @track casesFiltered = []; // filtered output
    @track filtersLength = 0;

    connectedCallback() {
        this.cases = this.mockCases(); // Load sample data
        this.applyFilters();
    }

    applyFilters() {
        const filters = [
            {
                field: "EnrollmentStatus__c",
                operator: "in",
                value: ["Enrolled", "Pending"]
            },
            {
                field: "TreatmentSite__c",
                operator: "equals",
                value: "TS001"
            },
            {
                field: "InfusionAppointmentDate__c",
                operator: "Date",
                value: "2025-04-15"
            },
            {
                field: "Trips__r", // Dynamic object
                operator: "nestedBetween",
                startField: "InfusionMonitoringArrivalTravelDate__c",
                endField: "InfusionMonitoringReturnTravelDate__c",
                value: ["2025-04-02", "2025-04-25"]
            }
        ];

        this.filtersLength = filters.length;

        this.casesFiltered = this.cases.filter(record => {
            return filters.every(filter => this.evaluateField(record, filter));
        });

        console.log("âœ… Filtered Output:", this.casesFiltered);
    }

    evaluateField(record, filter) {
        const path = filter.field.split('.');
        return this.resolvePath(record, path, filter);
    }

    resolvePath(obj, pathArr, filter) {
        const key = pathArr[0];

        if (Array.isArray(obj)) {
            return obj.some(item => this.resolvePath(item, pathArr, filter));
        }

        if (pathArr.length === 1) {
            const value = obj?.[key];

            // Handle dynamic nested fields for specific operators
            if (key === filter.field && filter.operator === 'nestedBetween') {
                return this.matchNestedBetween(obj, filter);
            }

            return this.matchFilter(value, filter);
        }

        const next = obj?.[key];

        if (Array.isArray(next)) {
            return next.some(item => this.resolvePath(item, pathArr.slice(1), filter));
        }

        return this.resolvePath(next, pathArr.slice(1), filter);
    }

    matchFilter(value, filter) {
        switch (filter.operator) {
            case "in":
            case "includes":
                return filter.value.includes(value);

            case "equals":
                return value === filter.value;

            case "Date":
                if (!value) return false;
                return this.isDateEqual(value, filter.value);

            case "Between":
                if (!value) return false;
                return this.isDateBetween(value, filter.value);

            default:
                return true;
        }
    }

    isDateEqual(value, filterValue) {
        const valDate = this.stripTime(new Date(value));
        const filterDate = this.stripTime(new Date(filterValue));
        return valDate.getTime() === filterDate.getTime();
    }

    isDateBetween(value, filterValue) {
        const valDate = this.stripTime(new Date(value));
        const [startDate, endDate] = filterValue.map(v => this.stripTime(new Date(v)));
        return valDate >= startDate && valDate <= endDate;
    }

    stripTime(date) {
        // Strips the time from the date, leaving just the year, month, and day
        const strippedDate = new Date(date);
        strippedDate.setHours(0, 0, 0, 0); // Set time to midnight
        return strippedDate;
    }

    matchNestedBetween(value, filter) {
        if (!value || !Array.isArray(value)) return false;

        // Get the date range from the filter
        const [startDate, endDate] = filter.value.map(date => this.stripTime(new Date(date)));

        // Check if either startField or endField falls within the range or equals the range dates
        return value.some(item => {
            const startFieldValue = item[filter.startField];
            const endFieldValue = item[filter.endField];

            const startDateValue = this.stripTime(new Date(startFieldValue));
            const endDateValue = this.stripTime(new Date(endFieldValue));

            const isStartInRange = (startDateValue >= startDate && startDateValue <= endDate) ||
                startDateValue.getTime() === startDate.getTime() || startDateValue.getTime() === endDate.getTime();

            const isEndInRange = (endDateValue >= startDate && endDateValue <= endDate) ||
                endDateValue.getTime() === startDate.getTime() || endDateValue.getTime() === endDate.getTime();

            return isStartInRange || isEndInRange;
        });
    }

    // Sample Data
    mockCases() {
        return [
            {
                EnrollmentStatus__c: "Enrolled",
                TreatmentSite__c: "TS001",
                InfusionAppointmentDate__c: "2025-04-15",
                Trips__r: [
                    {
                        InfusionMonitoringArrivalTravelDate__c: "2025-04-10",
                        InfusionMonitoringReturnTravelDate__c: "2025-04-20"
                    }
                ]
            },
            {
                EnrollmentStatus__c: "Declined",
                TreatmentSite__c: "TS002",
                InfusionAppointmentDate__c: "2025-05-01",
                Trips__r: [
                    {
                        InfusionMonitoringArrivalTravelDate__c: "2026-01-01",
                        InfusionMonitoringReturnTravelDate__c: "2026-01-05"
                    }
                ]
            }
        ];
    }
}
