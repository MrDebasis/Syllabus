import { LightningElement, track } from 'lwc';

export default class CaseFilter extends LightningElement {
    @track cases = [];
    @track casesFiltered = [];
    @track filtersLength = 0;

    connectedCallback() {
        this.cases = this.mockCases();
        this.applyFilters();
    }

    applyFilters() {
        const filters = [
            {
                field: "Trips__r",
                operator: "NestedDateEquals",
                startField: "InfusionMonitoringArrivalTravelDate__c",
                value: "2025-04-10"
            },
            {
                field: "Trips__r",
                operator: "NestedBetween",
                startField: "InfusionMonitoringArrivalTravelDate__c",
                endField: "InfusionMonitoringReturnTravelDate__c",
                value: ["2024-01-01", "2025-12-31"]
            }
        ];

        this.filtersLength = filters.length;

        this.casesFiltered = this.cases.filter(record => {
            return filters.every(filter => this.evaluateField(record, filter));
        });

        console.log("âœ… Filtered Output:", this.casesFiltered);
    }

    evaluateField(record, filter) {
        if (filter.operator === "NestedBetween") {
            return this.matchNestedDateRange(record[filter.field], filter);
        } else if (filter.operator === "NestedDateEquals") {
            return this.matchNestedDateEquals(record[filter.field], filter);
        } else {
            const path = filter.field.split('.');
            return this.resolvePath(record, path, filter);
        }
    }

    resolvePath(obj, pathArr, filter) {
        const key = pathArr[0];

        if (Array.isArray(obj)) {
            return obj.some(item => this.resolvePath(item, pathArr, filter));
        }

        if (pathArr.length === 1) {
            const value = obj?.[key];

            if (Array.isArray(value)) {
                return value.some(item => this.matchFilter(item, filter));
            }

            return this.matchFilter(value, filter);
        }

        const next = obj?.[key];

        if (Array.isArray(next)) {
            return next.some(item => this.resolvePath(item, pathArr.slice(1), filter));
        }

        return this.resolvePath(next, pathArr.slice(1), filter);
    }

    matchFilter(value, filter) {
        switch (filter.operator) {
            case "in":
            case "includes":
                return filter.value.includes(value);

            case "equals":
                return value === filter.value;

            case "Date":
                if (!value) return false;
                return this.formatDateOnly(value) === this.formatDateOnly(filter.value);

            case "Between":
                if (!value) return false;
                const valDate = new Date(this.formatDateOnly(value));
                const [start, end] = filter.value.map(v => new Date(this.formatDateOnly(v)));
                return valDate >= start && valDate <= end;

            default:
                return true;
        }
    }

    matchNestedDateRange(array, filter) {
        if (!array || !Array.isArray(array)) return false;

        const [startDate, endDate] = filter.value.map(v => new Date(this.formatDateOnly(v)));

        return array.some(item => {
            let match = false;
            if (item[filter.startField]) {
                const valStart = new Date(this.formatDateOnly(item[filter.startField]));
                match = match || (valStart >= startDate && valStart <= endDate);
            }
            if (item[filter.endField]) {
                const valEnd = new Date(this.formatDateOnly(item[filter.endField]));
                match = match || (valEnd >= startDate && valEnd <= endDate);
            }
            return match;
        });
    }

    matchNestedDateEquals(array, filter) {
        const targetDate = this.formatDateOnly(filter.value);
        return array?.some(item => {
            const dateVal = item[filter.startField];
            return dateVal && this.formatDateOnly(dateVal) === targetDate;
        });
    }

    formatDateOnly(date) {
        return new Date(date).toISOString().split('T')[0];
    }

    mockCases() {
        return [
            {
                EnrollmentStatus__c: "Enrolled",
                TreatmentSite__c: "TS001",
                InfusionAppointmentDate__c: "2025-04-15",
                Trips__r: [
                    {
                        InfusionMonitoringArrivalTravelDate__c: "2025-04-10",
                        InfusionMonitoringReturnTravelDate__c: "2025-04-20"
                    }
                ]
            },
            {
                EnrollmentStatus__c: "Enrolled",
                TreatmentSite__c: "TS002",
                InfusionAppointmentDate__c: "2024-03-01",
                Trips__r: [
                    {
                        InfusionMonitoringArrivalTravelDate__c: "2026-01-01",
                        InfusionMonitoringReturnTravelDate__c: "2026-01-10"
                    }
                ]
            }
        ];
    }
}
