@AuraEnabled
public static void saveRecord(List<Map<String, Object>> payloadList) {
    List<SObject> recordsToUpdate = new List<SObject>();

    for (Map<String, Object> payload : payloadList) {
        try {
            String recordId = (String) payload.get('recordId');
            String objectApiName = (String) payload.get('objectApiName');
            String fieldName = (String) payload.get('fieldName');
            Object updatedValue = payload.get('updatedValue');

            if (String.isEmpty(recordId) || String.isEmpty(objectApiName) || String.isEmpty(fieldName)) continue;

            SObjectType sObjectType = Schema.getGlobalDescribe().get(objectApiName);
            if (sObjectType == null) continue;

            SObject record = sObjectType.newSObject(recordId);
            Map<String, Schema.SObjectField> fieldMap = sObjectType.getDescribe().fields.getMap();

            if (!fieldMap.containsKey(fieldName)) continue;

            Schema.SObjectField field = fieldMap.get(fieldName);
            Schema.DisplayType fieldType = field.getDescribe().getType();

            switch on fieldType {
                when DATE {
                    record.put(fieldName, Date.valueOf((String) updatedValue));
                }
                when DATETIME {
                    record.put(fieldName, DateTime.valueOf((String) updatedValue));
                }
                when BOOLEAN {
                    record.put(fieldName, Boolean.valueOf((String) updatedValue));
                }
                when INTEGER {
                    record.put(fieldName, Integer.valueOf((String) updatedValue));
                }
                when DOUBLE {
                    record.put(fieldName, Double.valueOf((String) updatedValue));
                }
                when CURRENCY {
                    record.put(fieldName, Decimal.valueOf((String) updatedValue));
                }
                when else {
                    record.put(fieldName, updatedValue);
                }
            }

            recordsToUpdate.add(record);

        } catch (Exception ex) {
            System.debug('Skipping payload due to error: ' + ex.getMessage());
            continue;
        }
    }

    if (!recordsToUpdate.isEmpty()) {
        update recordsToUpdate;
    }
}


@track showSpinner = false;

async handleSave() {
    this.showSpinner = true;

    const payloadList = [];

    for (const rowId in this.editedValues) {
        const updatedRow = this.processedCases.find(row => row.Id === rowId);
        if (!updatedRow) continue;

        const updatedValues = this.editedValues[rowId];
        if (!updatedValues || Object.keys(updatedValues).length === 0) continue;

        Object.entries(updatedValues).forEach(([fieldName, updatedValue]) => {
            payloadList.push({
                recordId: rowId,
                objectApiName: updatedRow.objectApiName || 'Case',
                fieldName,
                updatedValue
            });
        });
    }

    if (payloadList.length === 0) {
        this.showSpinner = false;
        this.showToastAfterSaving('success', `No changes to save.`);
        return;
    }

    try {
        await saveRecord({ payloadList });

        // Update local UI (reuse your UI update logic or simplify)
        for (const payload of payloadList) {
            const { recordId, fieldName, updatedValue } = payload;

            this.processedCases = this.processedCases.map(row => {
                if (row.Id === recordId) {
                    return {
                        ...row,
                        columns: row.columns.map(col => ({
                            ...col,
                            value: col.field === fieldName ? updatedValue : col.value,
                            isEditing: false,
                            cellClass: ''
                        })),
                        isEditing: false,
                        detailRowKeyForSaveAndCancel: null
                    };
                }
                return row;
            });

            this.cases = this.cases.map(row => {
                if (row.Id === recordId) {
                    const targetKey = Object.keys(row).find(k => k.toLowerCase() === fieldName.toLowerCase());
                    if (targetKey) row[targetKey] = updatedValue;
                }
                return row;
            });
        }

        this.editedValues = {}; // Clear all edits
        this.showToastAfterSaving('success', `Records updated successfully.`);
    } catch (error) {
        console.error('Bulk save error:', error);
        this.showToastAfterSaving('error', `Error saving records: ${
            error.message || (error.body && error.body.message) || JSON.stringify(error)
        }`);
    } finally {
        this.showSpinner = false;
    }
}
